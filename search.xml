<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F05%2F05%2FBP%E7%A5%9E%E7%BB%8F%E5%BF%98%E4%BA%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[BP神经网络学习笔记目录 神经网络进行学习的基本前提 后向反馈神经网络两个假设与四个方程 实现 超参数的选择 存在的问题与优化点 为什么神经网络能够『解决』『所有』问题 神经网络进行学习的基本前提神经网络之所以能够进行学习，最基本的要素就是，对某个权值（weight）或者偏移值（biases）的轻微修改最终会造成结果的轻微修改。在此基础上，我们就可以通过对weight与biases的修改，来使最终输出结果朝越来越好的结果变化。重复这个过程，就能保证整个网络在数据的基础上正常的运作起来。如下图所示： 但问题在于，神经网络各个节点与下一层节点的全连接，导致一个节点激活值的变化影响了下一层所有神经元的输入，并进一步影响后续所有神经元的输入与输出。因此，神经网络最关键的一点就是，激活函数的选择，保证输出值变化的平滑。如上述公式所描述，最终结果的变化为权值与偏移值的线性变化，以此保证了输出值变化的可控程度。 当我们对权值矩阵进行了一个微小的修改：这个修改首先会反应在该神经元的激活值上：这个激活值的变化最终反应到输出层的变化：即： 其中，描述的是最终结果对wjk的敏感程度 如果选中其中一条变化的路线，可以描述为： 因此，问题的关键在于保证一系列的求导的乘积能够保证『稳定』的变化 如果选择阶跃函数作为激活函数，这一个输入的轻微变化可能导致输出由0变成1，进而影响下一层所有邻接神经元，最终对输出造成极大的变化。因而，在神经网络中，经常选择sigmoid function作为激活函数，这类神经元也被称为S型神经元。权值与偏移值的微小变化，同样反应在输出值的微小变化。 因此，隐藏层中一个轻微的修改最终将对输出结果造成轻微的影响，在此基础上，我们就可以通过weight与biases的修改保证最终输出朝着预期的方向『平稳』地改进。 后向反馈神经网络两个假设与四个方程### 两个假设假设1假设2四个方程 BP1方程一描述的是误差变量的定义，这个变量存在的目的是将反向传播过程中权值矩阵和偏移值矩阵的梯度联系起来。 BP2方程二描述的是反向传播过程中误差值的传播，从输出层的误差向前传播，并将误差逐层记录，推导过程如下： BP3方程三将误差变量与偏移矩阵的梯度关联在一起 BP4方程四将误差变量与权重矩阵的梯度关联在一起 实现假设和BP指定了在神经网络训练过程中权值矩阵和偏移矩阵梯度的获取方式，通过类似DP的方式降低了求导的计算量。在原有的计算方法中，对weight或biases的偏导通过链式法则的方式计算，存在极大的重复计算量，特别是在节点规模和weight矩阵规模增大时将呈指数增长。 SGD是入口函数，主要完成训练样本的散列和分批计算，通过调用update_mini_batch，完成批数据的训练 update_mini_batch主要完成样本点的前向传播，后向反馈过程，并在后向反馈过程中更新权值矩阵和便宜矩阵。其中： backpop完成后向反馈过程，并将误差变量记录 weight和biases的更新使用梯度下降方式更新 超参数的选择存在的问题与优化点为什么神经网络能够『解决』『所有』问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《Node.js学习笔记（一）：内存控制与垃圾回收》]]></title>
      <url>%2F2016%2F12%2F01%2Fnode-gc-part1%2F</url>
      <content type="text"><![CDATA[Node就是一群前端的自嗨 &lt;-未完待续-&gt; V8的垃圾回收机制Scavenge算法之前已经提到过，在V8将内存分为新生代和老生代两部分。而内存的分配主要集中在新生代部分，同时，新生代部分因为存活对象比较少，因此，新生代部分的垃圾回收主要使用scavenge算法。算法将新生代分成From区和To区，内存的分配主要是在From区中进行。当内存分配过程中allocationPtr指针到达From区结尾，就将触发垃圾回收机制。 可达性分析：即通过一系列称为GC ROOT的对象作为起点，从这些节点开始向下进行搜索，搜索走过的路径称为引用链,当一个对象到GC ROOT没有任何引用链，则证明该对象不可达。 一个等价约定：如果一个对象可经由某个被定义为活跃对象的对象，通过某个指针链所访问，则它就是活跃的。其他的都被视为垃圾 算法基本流程算法对应的伪码如下描述：12345678910111213141516171819202122232425262728293031def scavenge(): swap(fromSpace, toSpace) allocationPtr = toSpace.bottom scanPtr = toSpace.bottom for i = 0..len(roots): root = roots[i] if inFromSpace(root): rootCopy = copyObject(&amp;allocationPtr, root) setForwardingAddress(root, rootCopy) roots[i] = rootCopy while scanPtr &lt; allocationPtr: obj = object at scanPtr scanPtr += size(obj) n = sizeInWords(obj) for i = 0..n: if isPointer(obj[i]) and not inOldSpace(obj[i]): fromNeighbor = obj[i] if hasForwardingAddress(fromNeighbor): toNeighbor = getForwardingAddress(fromNeighbor) else: toNeighbor = copyObject(&amp;allocationPtr, fromNeighbor) setForwardingAddress(fromNeighbor, toNeighbor) obj[i] = toNeighbordef copyObject(*allocationPtr, object): copy = *allocationPtr *allocationPtr += size(object) memcpy(copy, object, size(object)) return copy 算法主要有下述几个步骤组成： 基本环境值修改，如交换From/To区指针等信息 将GC ROOT根节点所有子节点从From区移动到To区 复制剩余存活节点 第二步复制结束后，allocationPtr指向下一个可复制位置，scanPtr指向第一个开始复制的位置 对[scanPtr,allocationPtr)这段区间中的每个对象进行判断 如果是指针，并且不在老生代中 如果已经移动到To区，直接修改指针指向的内存地址 否则，将指针指向的对象移动到To区，同时修改指针指向的内存地址 重复整个流程，指导scanPtr = allocationPtr 整个流程其实类似一个广度优先搜索，从GC ROOT开始，一层一层地往下搜索，直到所有被引用的存活对象都被访问并且被移动到To区为止。 写屏障上节讲到，在存活对象的遍历过程中，会根据GC ROOT判断某个对象是否存活。如果有个位于老生代的指针指向了新生代中某个对象，这时候如果需要去遍历整个老生代，在时间上的消耗将很大。V8的解决方案是在老生代指针指向新生代对象时设置一个写屏障。 当一个新生代对象刚生成的时候，并不存在一个指向它的指针 当存在一个老生代对象指向它时，在写屏障中记录这个信息 当一个新生代对象晋升时，在写屏障中记录这个信息 Mark-Sweep&amp;Mark-Compact算法​ Scavenge算法之所以在新生代垃圾回收中能够有效运行，很大程度上取决于新生代对象在一次垃圾回收后存活对象比较少。但是，老生代对象在每轮垃圾回收中都会有大量的存活对象，这时候如果使用Scavenge算法，将不可避免造成大量的内存移动，因此，V8中使用Mark-Sweep和Mark-Compact算法进行垃圾回收。 标记算法 位图区：内存页还含有一个页头（包含一些元数据和标识信息）以及一个位图区（用以标记哪些对象是活跃的），位示图是利用二进制的一位来表示磁盘中一个块的作用情况，当其值为0 时表示对应盘块空闲；值为1时盘块已分配。磁盘上所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位形成了一个集合称为位示图，位示图用磁盘块存放，称为位图块。 在标记阶段，每个页都会有一个页图用来做标记的位图，位图中每一位代表页中一个字（注：一个字就是一个指针的大小，考虑到指针可能在一页中任何位子出现，） 标记清除和标记压缩算法的第一步都是标记存活对象，具体流程如下伪码所示： 1234567891011121314151617181920212223242526272829303132333435markingDeque = []overflow = falsedef markHeap(): for root in roots: mark(root) do: if overflow: overflow = false refillMarkingDeque() while !markingDeque.isEmpty(): obj = markingDeque.pop() setMarkBits(obj, BLACK) for neighbor in neighbors(obj): mark(neighbor) while overflow def mark(obj): if markBits(obj) == WHITE: setMarkBits(obj, GREY) if markingDeque.isFull(): overflow = true else: markingDeque.push(obj)def refillMarkingDeque(): for each obj on heap: if markBits(obj) == GREY: markingDeque.push(obj) if markingDeque.isFull(): overflow = true return ### 参考文献 https://bugs.chromium.org/p/v8/issues/detail?id=847 http://www.linuxidc.com/Linux/2015-03/115186.htm http://t.viewpoint.gr/node/deps/v8/src/heap.cc http://gold.xitu.io/entry/564ae48200b0d1db3385688e https://github.com/drewfish/node-tick-processor http://newhtml.net/v8-garbage-collection/ http://www.csdn.net/article/1970-01-01/2826316]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[序]]></title>
      <url>%2F2016%2F11%2F24%2Fhelloworld%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;世界上有两件东西能够深深地震撼人们的心灵，一件是我们心中崇高的道德准则，另一件是我们头顶上灿烂的星空。 过去&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引言其实和这篇序没什么关系，只不过是我很喜欢的一句话。曾经有一个大神大晚上赤裸上半身、抱着把吉他来213寝室，深情的说了这句我很喜欢的话，虽然我忘了上下文，虽然我觉得他单纯为了装逼，不过，我喜欢。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到现在我还记得很多年前那个夏天的早晨，九点的教学楼到处弥漫着那个小岛上夏天特有的味道，慵懒的阳光和通宵打游戏后朦胧的睁不开的双眼。不为什么，只是感觉，那几年是人生中最好的时光，懒散、无虑，有大把大把的时间可以瘫在图书馆顶楼的沙发上思考自己想做什么，虽然一般除了抄作业就是看小说。我其实很喜欢小岛上的时光，我想念烧仙草、大开杯、海蛎煎、黄则和还有大径村那条小吃街上所有的小吃，还有那个我吃了好几年没变过的香菇鸡丁盖浇饭配纯牛奶。虽然养成了拖延癌晚期，但那里改变了我的一切。 现在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一眨眼来帝都快一年了，一年前的这时候，我还在先研院的单间里通宵打游戏，那时候我做梦都想不到，现在会在这个离家一千多里的地方一个人学习、工作、生活。记得那时候刚下火车，我好奇的看了眼地铁口茫茫人海，琢磨了好久才想明白自己已经在一个完全陌生的地方，一个自己几个月前还坚定的认为打死也不来的地方，去面对一群没见过面的人。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人生就是这么的奇妙。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有的时候，拼命想去获取一个看似应该属于自己的东西，一个晃神老天就狠狠散了你一巴掌，然后缺心眼地嘲讽你的无能。命是个很操蛋的东西，不是你的东西，你怎么努力抢也抢不到，关键你还会觉得这真的是你的东西啊。就像很久以前，我就是想找个离家近点的学校，最后脸被啪啪啪地抽肿。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我一直觉得自己是个不爱折腾不思进取不求变化的人，偏偏误打误撞当了个程序员，当然不思进取可能有点过。作为一名非典型码农，你要我开篇写个Helloworld，诶，我觉得你是在污辱我情操，但凡有点底线的码农都不会跟风写个Helloworld，你写个HelloKitty都行，虽然码农并不是什么很丢脸的事。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我费尽心思琢磨了好久，想写点带点灰色嘲讽的『序』来凸显自己的高逼格，以作为哥哥职业生涯的开端，然后才发现，自己已经不比当年的才思泉涌，上了年纪的人，思绪有点慢，那就酱紫吧。 未来&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多年前我第一次踏进大学校门的时候，就明白了一个道理。大家都说，没有人会知道自己的未来是怎样。其实这话不对。大家都知道自己的未来是什么样的，但是又不敢承认，也不知道这个未来要多久，有多难，这个未来和我预期的有多大的契合度，自己能不能在这个过程中坚持下来，又愿意付出多少。这事其实很残酷。然后，还有很多鸡汤会和你说，年轻人不要急，一步一步慢慢来。哔哔哔哔，如果年轻的时候，我一定会这么说，我不远千里跑到这人生地不熟的地方你叫我慢慢来，是你逗我还是想我逗你。不过想想现在都二十好几了，还是慢慢来吧。 后记&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大晚上的，居然有个小哥说我浪，诶，人如果不浪，那和咸鱼有什么区别？]]></content>
    </entry>

    
  
  
</search>
